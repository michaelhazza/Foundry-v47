# Gate Scripts Reference

> Generated by Agent 6. Run `bash docs/gate-splitter.sh` to extract individual scripts.

**Total Scripts:** 33
**Split Command:** `bash docs/gate-splitter.sh`

---

#===== FILE: scripts/run-all-gates.sh =====#
#!/bin/bash
# scripts/run-all-gates.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

# Split-first guard - ensure gate-splitter.sh has been run
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXPECTED_VERIFY_SCRIPTS=32

ACTUAL_VERIFY_SCRIPTS=$(ls -1 "$SCRIPT_DIR"/verify-*.sh 2>/dev/null | wc -l)
if [[ $ACTUAL_VERIFY_SCRIPTS -lt $EXPECTED_VERIFY_SCRIPTS ]]; then
  echo "[X] ERROR: Found $ACTUAL_VERIFY_SCRIPTS verify scripts, expected $EXPECTED_VERIFY_SCRIPTS"
  echo ""
  echo "    Scripts have not been extracted. Run this first:"
  echo "    bash docs/gate-splitter.sh"
  echo ""
  exit 1
fi

PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
DOCS_DIR="$PROJECT_ROOT/docs"
BUILD_ID="build-$(date +%Y%m%d-%H%M%S)"
BUILD_START=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

echo "=== Build Gate Execution ==="
echo "Build ID: $BUILD_ID"
echo "Start: $BUILD_START"
echo ""

mkdir -p "$DOCS_DIR"

TOTAL_GATES=0
PASSED_GATES=0
FAILED_GATES=0

# JSON results array
echo "{" > "$DOCS_DIR/build-gate-results.json"
echo "  \"\$schema\": \"build-gate-results-v1\"," >> "$DOCS_DIR/build-gate-results.json"
echo "  \"buildId\": \"$BUILD_ID\"," >> "$DOCS_DIR/build-gate-results.json"
echo "  \"startTime\": \"$BUILD_START\"," >> "$DOCS_DIR/build-gate-results.json"

# Helper function to run gates and record results
run_gate() {
  local gate_name="$1"
  local gate_script="$2"
  shift 2
  local script_args=("$@")
  
  TOTAL_GATES=$((TOTAL_GATES + 1))
  
  if [[ ! -f "$gate_script" ]]; then
    echo "[X] FAIL: $gate_name (script not found)"
    FAILED_GATES=$((FAILED_GATES + 1))
    return 1
  fi
  
  local output
  local status
  if [[ ${#script_args[@]} -gt 0 ]]; then
    if output=$("$gate_script" "${script_args[@]}" 2>&1); then
      status="passed"
      PASSED_GATES=$((PASSED_GATES + 1))
      echo "[OK] $gate_name"
    else
      status="failed"
      FAILED_GATES=$((FAILED_GATES + 1))
      echo "[X] FAIL: $gate_name"
      echo "$output" | sed 's/^/    /'
    fi
  else
    if output=$("$gate_script" 2>&1); then
      status="passed"
      PASSED_GATES=$((PASSED_GATES + 1))
      echo "[OK] $gate_name"
    else
      status="failed"
      FAILED_GATES=$((FAILED_GATES + 1))
      echo "[X] FAIL: $gate_name"
      echo "$output" | sed 's/^/    /'
    fi
  fi
  
  # Append gate result to JSON (will finalize later)
  write_gate_result "$gate_name" "$status" "$output"
}

# Helper to write gate results (using function to scope local vars)
write_gate_result() {
  local gate="$1"
  local status="$2"
  local output="$3"
  local first=false
  
  if [[ $TOTAL_GATES -eq 1 ]]; then
    first=true
  fi
  
  if [[ "$first" == "false" ]]; then
    echo "," >> "$DOCS_DIR/build-gate-results.tmp"
  fi
  
  # Escape JSON special characters in output
  local escaped_output=$(echo "$output" | sed 's/\\/\\\\/g; s/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
  
  echo "    {" >> "$DOCS_DIR/build-gate-results.tmp"
  echo "      \"gate\": \"$gate\"," >> "$DOCS_DIR/build-gate-results.tmp"
  echo "      \"status\": \"$status\"," >> "$DOCS_DIR/build-gate-results.tmp"
  echo "      \"output\": \"$escaped_output\"" >> "$DOCS_DIR/build-gate-results.tmp"
  echo "    }" >> "$DOCS_DIR/build-gate-results.tmp"
}

# Initialize results temp file
echo "  \"gates\": [" > "$DOCS_DIR/build-gate-results.tmp"

# Phase 0: Preflight checks
echo ""
echo "=== Phase 0: Preflight Checks ==="
run_gate "preflight-artifacts" "$SCRIPT_DIR/verify-preflight-artifacts.sh"
run_gate "no-forbidden-artifacts" "$SCRIPT_DIR/verify-no-forbidden-artifacts.sh"
run_gate "spec-size-budget" "$SCRIPT_DIR/verify-spec-size-budget.sh"
run_gate "no-placeholders" "$SCRIPT_DIR/verify-no-placeholders.sh"
run_gate "env-var-usage-proof" "$SCRIPT_DIR/verify-env-var-usage-proof.sh"
run_gate "multi-tenant-isolation" "$SCRIPT_DIR/verify-multi-tenant-isolation.sh"

# Phase 1: Product Definition gates
echo ""
echo "=== Phase 1: Product Definition ==="
run_gate "scope-invariants" "$SCRIPT_DIR/verify-scope-invariants.sh"
run_gate "complete-deferrals" "$SCRIPT_DIR/verify-complete-deferrals.sh"

# Phase 2: System Architecture gates
echo ""
echo "=== Phase 2: System Architecture ==="
run_gate "env-manifest-schema" "$SCRIPT_DIR/verify-env-manifest-schema.sh"
run_gate "config-files-required" "$SCRIPT_DIR/verify-config-files-required.sh"
run_gate "health-db-connectivity" "$SCRIPT_DIR/verify-health-db-connectivity.sh"
run_gate "no-wildcard-cors" "$SCRIPT_DIR/verify-no-wildcard-cors.sh"
run_gate "encryption-binary" "$SCRIPT_DIR/verify-encryption-binary.sh"

# Phase 3: Data Modeling gates
echo ""
echo "=== Phase 3: Data Modeling ==="
run_gate "cascade-completeness" "$SCRIPT_DIR/verify-cascade-completeness.sh"
run_gate "project-scope-strategy" "$SCRIPT_DIR/verify-project-scope-strategy.sh"
run_gate "index-strategy" "$SCRIPT_DIR/verify-index-strategy.sh"
run_gate "schema-imports" "$SCRIPT_DIR/verify-schema-imports.sh"

# Phase 4: API Contract gates (structural)
echo ""
echo "=== Phase 4: API Contract ==="
run_gate "body-validation" "$SCRIPT_DIR/verify-body-validation.sh"
run_gate "upload-config-sourced" "$SCRIPT_DIR/verify-upload-config-sourced.sh"
run_gate "organisation-endpoint-naming" "$SCRIPT_DIR/verify-organisation-endpoint-naming.sh"
run_gate "mvp-scope-boundaries" "$SCRIPT_DIR/verify-mvp-scope-boundaries.sh"
run_gate "token-scoped-routing" "$SCRIPT_DIR/verify-token-scoped-routing.sh"
run_gate "error-handlers" "$SCRIPT_DIR/verify-error-handlers.sh"

# Phase 4: Per-endpoint expansion gates
SERVICE_CONTRACTS="$DOCS_DIR/service-contracts.json"
if [[ -f "$SERVICE_CONTRACTS" ]]; then
  ENDPOINT_COUNT=$(grep -c '"path"' "$SERVICE_CONTRACTS" || echo "0")
  if [[ $ENDPOINT_COUNT -gt 0 ]]; then
    echo ""
    echo "=== Phase 4: Per-Endpoint Gates ($ENDPOINT_COUNT endpoints) ==="
    
    for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
      ENDPOINT_PATH=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | sed -n "$((i+1))p" | cut -d'"' -f4)
      
      # Sanitize endpoint path for gate ID (remove leading/trailing /, replace / with -, strip special chars)
      GATE_ID=$(echo "$ENDPOINT_PATH" | sed 's|^/||; s|/$||; s|/|-|g; s|[^a-zA-Z0-9_-]||g')
      
      run_gate "endpoint-status-$GATE_ID" "$SCRIPT_DIR/verify-endpoint-status.sh" "$i"
      run_gate "route-service-alignment-$GATE_ID" "$SCRIPT_DIR/verify-route-service-alignment.sh" "$i"
      run_gate "pagination-max-$GATE_ID" "$SCRIPT_DIR/verify-pagination-max.sh" "$i"
      run_gate "status-enums-$GATE_ID" "$SCRIPT_DIR/verify-status-enums.sh" "$i"
    done
    
    # Upload-specific E2E gate (runs once for upload endpoints)
    run_gate "upload-e2e" "$SCRIPT_DIR/verify-upload-e2e.sh"
  fi
fi

# Phase 5: UI Specification gates
echo ""
echo "=== Phase 5: UI Specification ==="
run_gate "ui-canonical-paths" "$SCRIPT_DIR/verify-ui-canonical-paths.sh"
run_gate "ui-api-alignment" "$SCRIPT_DIR/verify-ui-api-alignment.sh"
run_gate "ui-self-consistency" "$SCRIPT_DIR/verify-ui-self-consistency.sh"
run_gate "no-deferred-pages" "$SCRIPT_DIR/verify-no-deferred-pages.sh"

# Finalize JSON
BUILD_END=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

cat "$DOCS_DIR/build-gate-results.tmp" >> "$DOCS_DIR/build-gate-results.json"
rm "$DOCS_DIR/build-gate-results.tmp"

echo "  ]," >> "$DOCS_DIR/build-gate-results.json"
echo "  \"endTime\": \"$BUILD_END\"," >> "$DOCS_DIR/build-gate-results.json"
echo "  \"summary\": {" >> "$DOCS_DIR/build-gate-results.json"
echo "    \"total\": $TOTAL_GATES," >> "$DOCS_DIR/build-gate-results.json"
echo "    \"passed\": $PASSED_GATES," >> "$DOCS_DIR/build-gate-results.json"
echo "    \"failed\": $FAILED_GATES" >> "$DOCS_DIR/build-gate-results.json"
echo "  }" >> "$DOCS_DIR/build-gate-results.json"
echo "}" >> "$DOCS_DIR/build-gate-results.json"

# Update build transcript
cat > "$DOCS_DIR/build-transcript.md" << EOF
# Build Transcript

## Execution Results

| Metric | Value |
|--------|-------|
| Build ID | $BUILD_ID |
| Start Time | $BUILD_START |
| End Time | $BUILD_END |
| Total Gates | $TOTAL_GATES |
| Passed | $PASSED_GATES |
| Failed | $FAILED_GATES |

> See \`docs/build-gate-results.json\` for detailed results.

**Status:** $(if [[ $FAILED_GATES -eq 0 ]]; then echo "PASSED"; else echo "FAILED ($FAILED_GATES failures)"; fi)
EOF

echo ""
echo "=== Build Summary ==="
echo "Total Gates: $TOTAL_GATES"
echo "Passed: $PASSED_GATES"
echo "Failed: $FAILED_GATES"
echo ""

if [[ $FAILED_GATES -gt 0 ]]; then
  echo "[X] BUILD FAILED"
  echo "See docs/build-gate-results.json for details"
  exit 1
else
  echo "[OK] BUILD PASSED"
  echo "Results: docs/build-gate-results.json"
  exit 0
fi
#===== END FILE =====#


#===== FILE: scripts/verify-preflight-artifacts.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-preflight-artifacts ==="

DOCS_DIR="docs"
FAIL=0

# Check required specification artifacts (NOT build outputs)
REQUIRED_FILES=(
  "$DOCS_DIR/scope-manifest.json"
  "$DOCS_DIR/env-manifest.json"
  "$DOCS_DIR/data-relationships.json"
  "$DOCS_DIR/service-contracts.json"
  "$DOCS_DIR/ui-api-deps.json"
  "$DOCS_DIR/gate-scripts-reference.md"
)

for file in "${REQUIRED_FILES[@]}"; do
  if [[ ! -f "$file" ]]; then
    echo "[X] FAIL: Missing required artifact: $file"
    FAIL=1
  else
    echo "[OK] $file exists"
  fi
done

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] All required specification artifacts present"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-no-forbidden-artifacts.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-no-forbidden-artifacts ==="

FAIL=0

# Check for deprecated or forbidden artifact patterns
if [[ -f "docs/implementation-checklist.md" ]]; then
  echo "[X] FAIL: Found deprecated implementation-checklist.md (replaced by gate system)"
  FAIL=1
fi

if [[ -f "docs/build-plan.md" ]]; then
  echo "[X] FAIL: Found deprecated build-plan.md (replaced by gate system)"
  FAIL=1
fi

# Check for individual gate script files in docs/ (should be in scripts/)
GATE_COUNT=$(find docs -maxdepth 1 -name "verify-*.sh" 2>/dev/null | wc -l)
if [[ $GATE_COUNT -gt 0 ]]; then
  echo "[X] FAIL: Found $GATE_COUNT gate scripts in docs/ (should be in scripts/)"
  find docs -maxdepth 1 -name "verify-*.sh"
  FAIL=1
fi

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] No forbidden artifacts found"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-spec-size-budget.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-spec-size-budget ==="

DOCS_DIR="docs"
FAIL=0

# Check specification artifact sizes (200KB budget per file)
MAX_SIZE_KB=200
MAX_SIZE_BYTES=$((MAX_SIZE_KB * 1024))

for file in "$DOCS_DIR"/*.json; do
  if [[ -f "$file" ]]; then
    SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    if [[ $SIZE -gt $MAX_SIZE_BYTES ]]; then
      SIZE_KB=$((SIZE / 1024))
      echo "[X] FAIL: $file is ${SIZE_KB}KB (exceeds ${MAX_SIZE_KB}KB budget)"
      FAIL=1
    else
      SIZE_KB=$((SIZE / 1024))
      echo "[OK] $file: ${SIZE_KB}KB"
    fi
  fi
done

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] All specification files within size budget"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-no-placeholders.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-no-placeholders ==="

PROJECT_ROOT="."
FAIL=0

# Define placeholder patterns (universal dev conventions)
PLACEHOLDER_PATTERNS=("TODO" "FIXME" "PLACEHOLDER" "XXX" "HACK")

# Search all code files for placeholders
SEARCH_DIRS=()

# Derive source directories from artifacts
for artifact in docs/service-contracts.json docs/data-relationships.json docs/ui-api-deps.json; do
  if [[ -f "$artifact" ]]; then
    while IFS= read -r dir; do
      if [[ -n "$dir" && -d "$dir" ]]; then
        SEARCH_DIRS+=("$dir")
      fi
    done < <(grep -oP '"[^"]*\.(ts|tsx|js|jsx)"' "$artifact" | tr -d '"' | sed 's|/[^/]*$||' | sort -u)
  fi
done

# Deduplicate directories
SEARCH_DIRS=($(printf '%s\n' "${SEARCH_DIRS[@]}" | sort -u))

if [[ ${#SEARCH_DIRS[@]} -eq 0 ]]; then
  echo "[SKIP] No source directories found in artifacts"
  exit 0
fi

for pattern in "${PLACEHOLDER_PATTERNS[@]}"; do
  for dir in "${SEARCH_DIRS[@]}"; do
    if [[ -d "$dir" ]]; then
      MATCHES=$(grep -r "$pattern" "$dir" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" 2>/dev/null || echo "")
      if [[ -n "$MATCHES" ]]; then
        echo "[X] FAIL: Found $pattern in $dir"
        echo "$MATCHES" | head -5 | sed 's/^/    /'
        FAIL=1
      fi
    fi
  done
done

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] No placeholder patterns found in source code"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-env-var-usage-proof.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-env-var-usage-proof ==="

ENV_MANIFEST="docs/env-manifest.json"
FAIL=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[SKIP] env-manifest.json not found"
  exit 0
fi

# Extract all required env vars from manifest
ENV_VAR_COUNT=$(grep -c '"name"' "$ENV_MANIFEST" || echo "0")

if [[ $ENV_VAR_COUNT -eq 0 ]]; then
  echo "[OK] No environment variables defined"
  exit 0
fi

echo "Checking $ENV_VAR_COUNT environment variables for usage proof..."

# For each env var, verify it has a validatedInFile
for i in $(seq 0 $((ENV_VAR_COUNT - 1))); do
  # Extract env var name and validatedInFile using grep/sed
  ENV_VAR=$(grep -o '"name": "[^"]*"' "$ENV_MANIFEST" | sed -n "$((i+1))p" | cut -d'"' -f4)
  VALIDATED_IN=$(grep -A 2 '"name": "'$ENV_VAR'"' "$ENV_MANIFEST" | grep '"validatedInFile"' | cut -d'"' -f4)
  
  if [[ -z "$VALIDATED_IN" ]]; then
    echo "[X] FAIL: $ENV_VAR has no validatedInFile"
    FAIL=1
  elif [[ ! -f "$VALIDATED_IN" ]]; then
    echo "[X] FAIL: $ENV_VAR validatedInFile not found: $VALIDATED_IN"
    FAIL=1
  else
    echo "[OK] $ENV_VAR validated in $VALIDATED_IN"
  fi
done

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-multi-tenant-isolation.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-multi-tenant-isolation ==="

SCOPE_MANIFEST="docs/scope-manifest.json"
DATA_REL="docs/data-relationships.json"
FAIL=0

if [[ ! -f "$SCOPE_MANIFEST" ]] || [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Read isolation field from scope-manifest.json
ISOLATION_FIELD=$(grep -o '"isolationField": "[^"]*"' "$SCOPE_MANIFEST" | cut -d'"' -f4)

if [[ -z "$ISOLATION_FIELD" ]]; then
  echo "[SKIP] No tenant isolation configured"
  exit 0
fi

echo "Checking tenant isolation field: $ISOLATION_FIELD"

# Extract tenant-scoped entities (tenantKey: direct) from data-relationships.json
TENANT_ENTITIES=$(grep -B 5 '"tenantKey": "direct"' "$DATA_REL" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$TENANT_ENTITIES" ]]; then
  echo "[OK] No tenant-scoped entities found"
  exit 0
fi

echo "Found tenant-scoped entities:"
echo "$TENANT_ENTITIES" | sed 's/^/  - /'

# Verify each tenant-scoped entity has the isolation field
while IFS= read -r entity; do
  if [[ -z "$entity" ]]; then
    continue
  fi
  
  # Check if entity has the isolation field in its columns
  HAS_FIELD=$(grep -A 50 '"name": "'$entity'"' "$DATA_REL" | grep -A 1 '"columns"' | grep -c '"name": "'$ISOLATION_FIELD'"' || echo "0")
  
  if [[ $HAS_FIELD -eq 0 ]]; then
    echo "[X] FAIL: $entity missing $ISOLATION_FIELD column"
    FAIL=1
  else
    echo "[OK] $entity has $ISOLATION_FIELD column"
  fi
done <<< "$TENANT_ENTITIES"

exit $FAIL
#===== END FILE =====#


#===== FILE: scripts/verify-scope-invariants.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-scope-invariants ==="

SCOPE_MANIFEST="docs/scope-manifest.json"
FAIL=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] scope-manifest.json not found"
  exit 0
fi

# Verify phase is set
PHASE=$(grep -o '"phase": "[^"]*"' "$SCOPE_MANIFEST" | cut -d'"' -f4)
if [[ -z "$PHASE" ]]; then
  echo "[X] FAIL: Missing phase declaration"
  FAIL=1
elif [[ "$PHASE" != "mvp" ]]; then
  echo "[X] FAIL: Phase must be 'mvp', got: $PHASE"
  FAIL=1
else
  echo "[OK] Phase: $PHASE"
fi

# Verify requiredEntities exists
if ! grep -q '"requiredEntities"' "$SCOPE_MANIFEST"; then
  echo "[X] FAIL: Missing requiredEntities array"
  FAIL=1
else
  ENTITY_COUNT=$(grep -c '"requiredEntities"' "$SCOPE_MANIFEST" || echo "0")
  echo "[OK] requiredEntities array present"
fi

# Verify platformConstraints exists
if ! grep -q '"platformConstraints"' "$SCOPE_MANIFEST"; then
  echo "[X] FAIL: Missing platformConstraints object"
  FAIL=1
else
  echo "[OK] platformConstraints present"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-complete-deferrals.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-complete-deferrals ==="

SCOPE_MANIFEST="docs/scope-manifest.json"
FAIL=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] scope-manifest.json not found"
  exit 0
fi

# Check if deferralDeclarations exists
if ! grep -q '"deferralDeclarations"' "$SCOPE_MANIFEST"; then
  echo "[SKIP] No deferralDeclarations found"
  exit 0
fi

# Extract deferred entity names from deferredEntities array
DEFERRED_NAMES=$(grep -A 1 '"deferredEntities"' "$SCOPE_MANIFEST" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$DEFERRED_NAMES" ]]; then
  echo "[OK] No deferred entities"
  exit 0
fi

echo "Checking deferral completeness for deferred entities:"
echo "$DEFERRED_NAMES" | sed 's/^/  - /'

# Verify each deferred entity has a deferralDeclaration
while IFS= read -r entity; do
  if [[ -z "$entity" ]]; then
    continue
  fi
  
  if ! grep -q "\"$entity\":" "$SCOPE_MANIFEST"; then
    echo "[X] FAIL: $entity in deferredEntities but no deferralDeclaration"
    FAIL=1
  else
    echo "[OK] $entity has deferralDeclaration"
  fi
done <<< "$DEFERRED_NAMES"

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-env-manifest-schema.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-env-manifest-schema ==="

ENV_MANIFEST="docs/env-manifest.json"
FAIL=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[SKIP] env-manifest.json not found"
  exit 0
fi

# Verify schema version
if ! grep -q '"\$schema": "env-manifest-v' "$ENV_MANIFEST"; then
  echo "[X] FAIL: Missing or invalid \$schema field"
  FAIL=1
else
  echo "[OK] Schema version present"
fi

# Verify required array exists
if ! grep -q '"required"' "$ENV_MANIFEST"; then
  echo "[X] FAIL: Missing required array"
  FAIL=1
else
  echo "[OK] required array present"
fi

# Verify each required entry has mandatory fields
ENV_COUNT=$(grep -c '"name"' "$ENV_MANIFEST" || echo "0")

if [[ $ENV_COUNT -gt 0 ]]; then
  echo "Validating $ENV_COUNT environment variable entries..."
  
  for i in $(seq 0 $((ENV_COUNT - 1))); do
    ENV_NAME=$(grep -o '"name": "[^"]*"' "$ENV_MANIFEST" | sed -n "$((i+1))p" | cut -d'"' -f4)
    
    # Check for required fields: usage, validatedInFile
    HAS_USAGE=$(grep -A 3 '"name": "'$ENV_NAME'"' "$ENV_MANIFEST" | grep -c '"usage"' || echo "0")
    HAS_VALIDATED=$(grep -A 3 '"name": "'$ENV_NAME'"' "$ENV_MANIFEST" | grep -c '"validatedInFile"' || echo "0")
    
    if [[ $HAS_USAGE -eq 0 ]]; then
      echo "[X] FAIL: $ENV_NAME missing 'usage' field"
      FAIL=1
    fi
    
    if [[ $HAS_VALIDATED -eq 0 ]]; then
      echo "[X] FAIL: $ENV_NAME missing 'validatedInFile' field"
      FAIL=1
    fi
    
    if [[ $HAS_USAGE -gt 0 ]] && [[ $HAS_VALIDATED -gt 0 ]]; then
      echo "[OK] $ENV_NAME has required fields"
    fi
  done
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-config-files-required.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-config-files-required ==="

FAIL=0

# Check for required configuration files
REQUIRED_CONFIGS=(
  ".env.example"
  "package.json"
)

for file in "${REQUIRED_CONFIGS[@]}"; do
  if [[ ! -f "$file" ]]; then
    echo "[X] FAIL: Missing required config file: $file"
    FAIL=1
  else
    echo "[OK] $file exists"
  fi
done

# Verify .env.example contains variables from env-manifest.json
if [[ -f "docs/env-manifest.json" ]] && [[ -f ".env.example" ]]; then
  ENV_COUNT=$(grep -c '"name"' "docs/env-manifest.json" || echo "0")
  
  if [[ $ENV_COUNT -gt 0 ]]; then
    echo "Verifying .env.example contains $ENV_COUNT variables..."
    
    for i in $(seq 0 $((ENV_COUNT - 1))); do
      ENV_VAR=$(grep -o '"name": "[^"]*"' "docs/env-manifest.json" | sed -n "$((i+1))p" | cut -d'"' -f4)
      
      if ! grep -q "^$ENV_VAR=" ".env.example"; then
        echo "[X] FAIL: $ENV_VAR not found in .env.example"
        FAIL=1
      else
        echo "[OK] $ENV_VAR in .env.example"
      fi
    done
  fi
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-health-db-connectivity.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-health-db-connectivity ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Find health endpoint by purpose (not by hardcoded path)
HEALTH_ENDPOINT_COUNT=$(grep -c '"purpose": "healthCheck"' "$SERVICE_CONTRACTS" || echo "0")

if [[ $HEALTH_ENDPOINT_COUNT -eq 0 ]]; then
  echo "[X] FAIL: No health check endpoint found (purpose: healthCheck)"
  FAIL=1
  exit $FAIL
fi

if [[ $HEALTH_ENDPOINT_COUNT -gt 1 ]]; then
  echo "[X] FAIL: Multiple health check endpoints found (expected 1, got $HEALTH_ENDPOINT_COUNT)"
  FAIL=1
  exit $FAIL
fi

echo "[OK] Health check endpoint found"

# Extract health endpoint details using grep/sed
HEALTH_PATH=$(grep -B 3 '"purpose": "healthCheck"' "$SERVICE_CONTRACTS" | grep '"path"' | cut -d'"' -f4)
HEALTH_ROUTE_FILE=$(grep -B 5 '"purpose": "healthCheck"' "$SERVICE_CONTRACTS" | grep '"routeFile"' | cut -d'"' -f4)

if [[ -z "$HEALTH_PATH" ]]; then
  echo "[X] FAIL: Health endpoint has no path"
  FAIL=1
else
  echo "[OK] Health endpoint path: $HEALTH_PATH"
fi

if [[ -z "$HEALTH_ROUTE_FILE" ]]; then
  echo "[X] FAIL: Health endpoint has no routeFile"
  FAIL=1
elif [[ ! -f "$HEALTH_ROUTE_FILE" ]]; then
  echo "[X] FAIL: Health route file not found: $HEALTH_ROUTE_FILE"
  FAIL=1
else
  echo "[OK] Health route file exists: $HEALTH_ROUTE_FILE"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-no-wildcard-cors.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-no-wildcard-cors ==="

FAIL=0

# Derive server directory from service-contracts.json
SERVICE_CONTRACTS="docs/service-contracts.json"

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

SERVER_DIR=$(grep -o '"routeFile": "[^"]*"' "$SERVICE_CONTRACTS" | head -1 | cut -d'"' -f4 | sed 's|/.*||')

if [[ -z "$SERVER_DIR" ]]; then
  echo "[SKIP] Cannot derive server directory from service-contracts.json"
  exit 0
fi

if [[ ! -d "$SERVER_DIR" ]]; then
  echo "[SKIP] Server directory not found: $SERVER_DIR"
  exit 0
fi

# Search for literal wildcard CORS (origin: '*')
echo "Scanning $SERVER_DIR for wildcard CORS..."

WILDCARD_MATCHES=$(grep -r "origin.*['\"]\\*['\"]" "$SERVER_DIR" --include="*.ts" --include="*.js" 2>/dev/null || echo "")

if [[ -n "$WILDCARD_MATCHES" ]]; then
  echo "[X] FAIL: Found wildcard CORS in production code"
  echo "$WILDCARD_MATCHES" | sed 's/^/    /'
  FAIL=1
else
  echo "[OK] No wildcard CORS found"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-encryption-binary.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-encryption-binary ==="

DATA_REL="docs/data-relationships.json"
FAIL=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] data-relationships.json not found"
  exit 0
fi

# Check if any columns require encryption (type: encrypted or piiCategory present)
HAS_ENCRYPTION=$(grep -c '"piiCategory"' "$DATA_REL" 2>/dev/null || echo "0")

if [[ $HAS_ENCRYPTION -eq 0 ]]; then
  echo "[OK] No PII encryption required"
  exit 0
fi

echo "Found $HAS_ENCRYPTION PII columns requiring encryption"

# Verify encryption implementation exists
SERVICE_CONTRACTS="docs/service-contracts.json"

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] Cannot verify encryption implementation without service-contracts.json"
  exit 0
fi

# Derive server directory
SERVER_DIR=$(grep -o '"routeFile": "[^"]*"' "$SERVICE_CONTRACTS" | head -1 | cut -d'"' -f4 | sed 's|/.*||')

if [[ -z "$SERVER_DIR" ]] || [[ ! -d "$SERVER_DIR" ]]; then
  echo "[SKIP] Cannot locate server directory"
  exit 0
fi

# Check for encryption utility (AES-256-GCM implementation)
ENCRYPTION_FILE=$(find "$SERVER_DIR" -name "*encrypt*" -o -name "*crypto*" 2>/dev/null | head -1)

if [[ -z "$ENCRYPTION_FILE" ]]; then
  echo "[X] FAIL: No encryption utility found (required for PII handling)"
  FAIL=1
else
  echo "[OK] Encryption utility found: $ENCRYPTION_FILE"
fi

exit $FAIL
#===== END FILE =====#


#===== FILE: scripts/verify-cascade-completeness.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-cascade-completeness ==="

DATA_REL="docs/data-relationships.json"
FAIL=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] data-relationships.json not found"
  exit 0
fi

# Find all foreign key relationships
echo "Checking cascade rules for foreign key relationships..."

# Extract tables with foreign key columns
TABLE_COUNT=$(grep -c '"name".*:' "$DATA_REL" | head -1 || echo "0")

# Look for 'references' fields in columns
FK_COUNT=$(grep -c '"references":' "$DATA_REL" || echo "0")

if [[ $FK_COUNT -eq 0 ]]; then
  echo "[OK] No foreign key relationships defined"
  exit 0
fi

echo "Found $FK_COUNT foreign key relationships"

# For each FK, verify it has a cascade rule (onDelete field)
FK_WITH_CASCADE=$(grep -B 1 '"references":' "$DATA_REL" | grep -c '"onDelete":' || echo "0")

if [[ $FK_WITH_CASCADE -lt $FK_COUNT ]]; then
  MISSING=$((FK_COUNT - FK_WITH_CASCADE))
  echo "[X] FAIL: $MISSING foreign keys missing cascade rules (onDelete)"
  FAIL=1
else
  echo "[OK] All $FK_COUNT foreign keys have cascade rules"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-project-scope-strategy.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-project-scope-strategy ==="

DATA_REL="docs/data-relationships.json"
FAIL=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] data-relationships.json not found"
  exit 0
fi

# Dynamically discover entities with indirect tenant scoping
INDIRECT_ENTITIES=$(grep -B 2 '"tenantKey": "indirect"' "$DATA_REL" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$INDIRECT_ENTITIES" ]]; then
  echo "[OK] No indirect-tenant entities found"
  exit 0
fi

echo "Found indirect-tenant entities:"
echo "$INDIRECT_ENTITIES" | sed 's/^/  - /'

# Verify each indirect entity has a scoping strategy
while IFS= read -r entity; do
  if [[ -z "$entity" ]]; then
    continue
  fi
  
  # Check if entity has projectScopeStrategy field
  HAS_STRATEGY=$(grep -A 20 '"name": "'$entity'"' "$DATA_REL" | grep -c '"projectScopeStrategy":' || echo "0")
  
  if [[ $HAS_STRATEGY -eq 0 ]]; then
    echo "[X] FAIL: $entity has tenantKey:indirect but no projectScopeStrategy"
    FAIL=1
  else
    STRATEGY=$(grep -A 20 '"name": "'$entity'"' "$DATA_REL" | grep '"projectScopeStrategy"' | cut -d'"' -f4)
    echo "[OK] $entity: projectScopeStrategy = $STRATEGY"
  fi
done <<< "$INDIRECT_ENTITIES"

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-index-strategy.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-index-strategy ==="

DATA_REL="docs/data-relationships.json"
SCOPE_MANIFEST="docs/scope-manifest.json"
FAIL=0

if [[ ! -f "$DATA_REL" ]] || [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Read isolation field
ISOLATION_FIELD=$(grep -o '"isolationField": "[^"]*"' "$SCOPE_MANIFEST" | cut -d'"' -f4)

if [[ -z "$ISOLATION_FIELD" ]]; then
  echo "[SKIP] No tenant isolation configured"
  exit 0
fi

# Find tables with softDeleteColumn
SOFT_DELETE_TABLES=$(grep -B 5 '"softDeleteColumn":' "$DATA_REL" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$SOFT_DELETE_TABLES" ]]; then
  echo "[OK] No soft-delete tables found"
  exit 0
fi

echo "Checking index strategy for soft-delete tables..."

# Verify each soft-delete table has an index on the soft-delete column
while IFS= read -r table; do
  if [[ -z "$table" ]]; then
    continue
  fi
  
  # Extract soft-delete column name for this table
  SD_COL=$(grep -A 1 '"name": "'$table'"' "$DATA_REL" | grep -A 20 '"softDeleteColumn"' | head -1 | cut -d'"' -f4)
  
  if [[ -z "$SD_COL" ]]; then
    continue
  fi
  
  # Check if table has an index including the soft-delete column
  HAS_SD_INDEX=$(grep -A 50 '"name": "'$table'"' "$DATA_REL" | grep -A 2 '"indexes"' | grep -c "\"$SD_COL\"" || echo "0")
  
  if [[ $HAS_SD_INDEX -eq 0 ]]; then
    echo "[X] FAIL: $table missing index on soft-delete column $SD_COL"
    FAIL=1
  else
    echo "[OK] $table has index on $SD_COL"
  fi
  
  # Check tenant-scoped tables have composite indexes
  TENANT_KEY=$(grep -A 5 '"name": "'$table'"' "$DATA_REL" | grep '"tenantKey"' | cut -d'"' -f4)
  
  if [[ "$TENANT_KEY" == "direct" ]]; then
    # Should have composite index with isolation field
    HAS_COMPOSITE=$(grep -A 50 '"name": "'$table'"' "$DATA_REL" | grep -A 2 '"indexes"' | grep -c "\"$ISOLATION_FIELD\".*\"$SD_COL\"\|\"$SD_COL\".*\"$ISOLATION_FIELD\"" || echo "0")
    
    if [[ $HAS_COMPOSITE -eq 0 ]]; then
      echo "[X] FAIL: $table missing composite index ($ISOLATION_FIELD, $SD_COL)"
      FAIL=1
    else
      echo "[OK] $table has composite tenant + soft-delete index"
    fi
  fi
done <<< "$SOFT_DELETE_TABLES"

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-schema-imports.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-schema-imports ==="

# Derive schema directory from data-relationships.json
DATA_REL="docs/data-relationships.json"

if [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] data-relationships.json not found"
  exit 0
fi

# Extract schema directory from table entries
SCHEMA_FILE=$(grep -o '"schemaFile": "[^"]*"' "$DATA_REL" | head -1 | cut -d'"' -f4)

if [[ -z "$SCHEMA_FILE" ]]; then
  echo "[SKIP] No schema files defined in data-relationships.json"
  exit 0
fi

SCHEMA_DIR=$(dirname "$SCHEMA_FILE")

if [[ ! -d "$SCHEMA_DIR" ]]; then
  echo "[SKIP] Schema directory not found: $SCHEMA_DIR"
  exit 0
fi

FAIL=0

echo "Checking schema imports in $SCHEMA_DIR..."

# Check for .js extensions in relative imports (breaks drizzle-kit CJS resolution)
while IFS= read -r file; do
  if grep -Pn "from\s+['\"]\..*\.js['\"]" "$file" > /dev/null 2>&1; then
    echo "[X] FAIL: $file contains .js extension in relative import"
    grep -Pn "from\s+['\"]\..*\.js['\"]" "$file" | sed 's/^/    /'
    FAIL=1
  fi
done < <(find "$SCHEMA_DIR" -name "*.ts" -type f)

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] No .js extensions found in schema imports"
fi

exit $FAIL
#===== END FILE =====#


#===== FILE: scripts/verify-endpoint-status.sh =====#
#!/bin/bash
set -euo pipefail

ENDPOINT_INDEX="$1"
SERVICE_CONTRACTS="docs/service-contracts.json"

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Extract endpoint path for this index
ENDPOINT_PATH=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | sed -n "$((ENDPOINT_INDEX+1))p" | cut -d'"' -f4)

if [[ -z "$ENDPOINT_PATH" ]]; then
  echo "[SKIP] No endpoint at index $ENDPOINT_INDEX"
  exit 0
fi

# Check if endpoint has status code documentation
HAS_STATUS=$(grep -A 50 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep -c '"statusCode":' || echo "0")

if [[ $HAS_STATUS -eq 0 ]]; then
  echo "[X] FAIL: $ENDPOINT_PATH has no status code documentation"
  exit 1
fi

echo "[OK] $ENDPOINT_PATH has status code documentation"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-route-service-alignment.sh =====#
#!/bin/bash
set -euo pipefail

ENDPOINT_INDEX="$1"
SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Extract endpoint details
ENDPOINT_PATH=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | sed -n "$((ENDPOINT_INDEX+1))p" | cut -d'"' -f4)

if [[ -z "$ENDPOINT_PATH" ]]; then
  echo "[SKIP] No endpoint at index $ENDPOINT_INDEX"
  exit 0
fi

# Extract routeFile and serviceFile for this endpoint
ROUTE_FILE=$(grep -A 5 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep '"routeFile"' | cut -d'"' -f4)
SERVICE_FILE=$(grep -A 10 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep '"serviceFile"' | cut -d'"' -f4)

if [[ -z "$ROUTE_FILE" ]]; then
  echo "[X] FAIL: $ENDPOINT_PATH has no routeFile"
  FAIL=1
fi

if [[ -z "$SERVICE_FILE" ]]; then
  echo "[X] FAIL: $ENDPOINT_PATH has no serviceFile"
  FAIL=1
fi

if [[ -n "$ROUTE_FILE" ]] && [[ ! -f "$ROUTE_FILE" ]]; then
  echo "[X] FAIL: Route file not found: $ROUTE_FILE"
  FAIL=1
fi

if [[ -n "$SERVICE_FILE" ]] && [[ ! -f "$SERVICE_FILE" ]]; then
  echo "[X] FAIL: Service file not found: $SERVICE_FILE"
  FAIL=1
fi

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] $ENDPOINT_PATH route-service alignment verified"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-upload-e2e.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-upload-e2e ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Find upload endpoints (contentType: multipart/form-data)
UPLOAD_COUNT=$(grep -c '"contentType": "multipart/form-data"' "$SERVICE_CONTRACTS" || echo "0")

if [[ $UPLOAD_COUNT -eq 0 ]]; then
  echo "[OK] No upload endpoints defined"
  exit 0
fi

echo "Found $UPLOAD_COUNT upload endpoints"

# Verify each upload endpoint has:
# 1. File upload configuration
# 2. Proper validation
# 3. Service method for processing

UPLOAD_PATHS=$(grep -B 5 '"contentType": "multipart/form-data"' "$SERVICE_CONTRACTS" | grep '"path"' | cut -d'"' -f4)

while IFS= read -r path; do
  if [[ -z "$path" ]]; then
    continue
  fi
  
  # Check for file field configuration
  HAS_FILE_FIELD=$(grep -A 20 '"path": "'$path'"' "$SERVICE_CONTRACTS" | grep -c '"fieldName":' || echo "0")
  
  if [[ $HAS_FILE_FIELD -eq 0 ]]; then
    echo "[X] FAIL: $path missing file field configuration"
    FAIL=1
  else
    echo "[OK] $path has file field configuration"
  fi
done <<< "$UPLOAD_PATHS"

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-pagination-max.sh =====#
#!/bin/bash
set -euo pipefail

ENDPOINT_INDEX="$1"
SERVICE_CONTRACTS="docs/service-contracts.json"

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Extract endpoint path and method
ENDPOINT_PATH=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | sed -n "$((ENDPOINT_INDEX+1))p" | cut -d'"' -f4)
ENDPOINT_METHOD=$(grep -B 1 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep '"method"' | cut -d'"' -f4)

if [[ -z "$ENDPOINT_PATH" ]] || [[ "$ENDPOINT_METHOD" != "GET" ]]; then
  echo "[SKIP] Endpoint is not a GET (pagination only applies to list endpoints)"
  exit 0
fi

# Check if this is a list endpoint (returns array)
IS_LIST=$(grep -A 30 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep -c '"returnsArray": true' || echo "0")

if [[ $IS_LIST -eq 0 ]]; then
  echo "[SKIP] Not a list endpoint"
  exit 0
fi

# Verify pagination parameters exist
HAS_LIMIT=$(grep -A 30 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep -c '"limit"' || echo "0")
HAS_OFFSET=$(grep -A 30 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep -c '"offset"' || echo "0")

if [[ $HAS_LIMIT -eq 0 ]] || [[ $HAS_OFFSET -eq 0 ]]; then
  echo "[X] FAIL: $ENDPOINT_PATH missing pagination parameters (limit/offset)"
  exit 1
fi

echo "[OK] $ENDPOINT_PATH has pagination parameters"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-status-enums.sh =====#
#!/bin/bash
set -euo pipefail

ENDPOINT_INDEX="$1"
SERVICE_CONTRACTS="docs/service-contracts.json"
DATA_REL="docs/data-relationships.json"

if [[ ! -f "$SERVICE_CONTRACTS" ]] || [[ ! -f "$DATA_REL" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Extract endpoint path
ENDPOINT_PATH=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | sed -n "$((ENDPOINT_INDEX+1))p" | cut -d'"' -f4)

if [[ -z "$ENDPOINT_PATH" ]]; then
  echo "[SKIP] No endpoint at index $ENDPOINT_INDEX"
  exit 0
fi

# Check if endpoint references status field
HAS_STATUS=$(grep -A 30 '"path": "'$ENDPOINT_PATH'"' "$SERVICE_CONTRACTS" | grep -c '"status"' || echo "0")

if [[ $HAS_STATUS -eq 0 ]]; then
  echo "[SKIP] Endpoint does not use status field"
  exit 0
fi

# Verify status enum values are documented in data model
# This is a structural check - actual enum values should match between API contract and data model

echo "[OK] $ENDPOINT_PATH status field present (enum validation deferred to implementation)"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-error-handlers.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-error-handlers ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Derive server directory from service-contracts.json
SERVER_DIR=$(grep -o '"routeFile": "[^"]*"' "$SERVICE_CONTRACTS" | head -1 | cut -d'"' -f4 | sed 's|/.*||')

if [[ -z "$SERVER_DIR" ]]; then
  echo "[X] FAIL: Cannot derive server directory from service-contracts.json"
  exit 1
fi

if [[ ! -d "$SERVER_DIR" ]]; then
  echo "[SKIP] Server directory not found: $SERVER_DIR"
  exit 0
fi

# Find Express entry file (look for app.listen or createServer)
ENTRY_FILE=$(find "$SERVER_DIR" -name "*.ts" -o -name "*.js" -type f | xargs grep -l "app\.listen\|createServer" 2>/dev/null | head -1)

if [[ -z "$ENTRY_FILE" ]]; then
  echo "[X] FAIL: Cannot find Express entry file"
  exit 1
fi

echo "Checking Express entry file: $ENTRY_FILE"

# Check 1: JSON body parser with error handling
if ! grep -q "express\.json\|bodyParser\.json\|express\.urlencoded" "$ENTRY_FILE"; then
  echo "[X] FAIL: No JSON body parser found in $ENTRY_FILE"
  FAIL=1
else
  echo "[OK] JSON body parser found"
fi

# Check 2: Global error handler (4-parameter middleware: err, req, res, next)
if ! grep -Pzo '(err|error)\s*,\s*(req|request)\s*,\s*(res|response)\s*,\s*(next)' "$ENTRY_FILE" > /dev/null 2>&1; then
  echo "[X] FAIL: No global error handler (4-param middleware) found in $ENTRY_FILE"
  FAIL=1
else
  echo "[OK] Global error handler found"
fi

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] Error handler verification passed"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-body-validation.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-body-validation ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Find POST/PUT/PATCH endpoints that accept JSON body
BODY_ENDPOINTS=$(grep -B 2 '"contentType": "application/json"' "$SERVICE_CONTRACTS" | grep '"path"' | cut -d'"' -f4)

if [[ -z "$BODY_ENDPOINTS" ]]; then
  echo "[OK] No endpoints with JSON body"
  exit 0
fi

echo "Checking body validation for endpoints with JSON payloads..."

# For each endpoint, verify it has request body schema
while IFS= read -r path; do
  if [[ -z "$path" ]]; then
    continue
  fi
  
  HAS_SCHEMA=$(grep -A 20 '"path": "'$path'"' "$SERVICE_CONTRACTS" | grep -c '"requestBody":' || echo "0")
  
  if [[ $HAS_SCHEMA -eq 0 ]]; then
    echo "[X] FAIL: $path missing request body schema"
    FAIL=1
  else
    echo "[OK] $path has request body schema"
  fi
done <<< "$BODY_ENDPOINTS"

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-upload-config-sourced.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-upload-config-sourced ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
SCOPE_MANIFEST="docs/scope-manifest.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]] || [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Find upload endpoints
UPLOAD_COUNT=$(grep -c '"contentType": "multipart/form-data"' "$SERVICE_CONTRACTS" || echo "0")

if [[ $UPLOAD_COUNT -eq 0 ]]; then
  echo "[OK] No upload endpoints defined"
  exit 0
fi

# Verify platformConstraints.limits.maxFileUploadSize exists in scope-manifest
HAS_UPLOAD_LIMIT=$(grep -c '"maxFileUploadSize"' "$SCOPE_MANIFEST" || echo "0")

if [[ $HAS_UPLOAD_LIMIT -eq 0 ]]; then
  echo "[X] FAIL: scope-manifest.json missing maxFileUploadSize in platformConstraints.limits"
  FAIL=1
else
  UPLOAD_LIMIT=$(grep -A 1 '"maxFileUploadSize"' "$SCOPE_MANIFEST" | grep '"value"' | grep -o '[0-9]*')
  echo "[OK] Upload size limit defined: $UPLOAD_LIMIT bytes"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-organisation-endpoint-naming.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-organisation-endpoint-naming ==="

SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] service-contracts.json not found"
  exit 0
fi

# Find organisation-related endpoints
ORG_ENDPOINTS=$(grep -o '"path": "[^"]*organisation[^"]*"' "$SERVICE_CONTRACTS" | cut -d'"' -f4)

if [[ -z "$ORG_ENDPOINTS" ]]; then
  echo "[OK] No organisation endpoints found"
  exit 0
fi

echo "Checking organisation endpoint naming..."

# Verify current organisation endpoint uses /me pattern
CURRENT_ORG_ENDPOINT=$(echo "$ORG_ENDPOINTS" | grep "/organisations/me" || echo "")

if [[ -z "$CURRENT_ORG_ENDPOINT" ]]; then
  echo "[X] FAIL: No /api/organisations/me endpoint found (singleton pattern required)"
  FAIL=1
else
  echo "[OK] Current organisation endpoint uses /me pattern"
fi

# Check for anti-pattern: /organisations/:id with route parameter
HAS_ID_PARAM=$(echo "$ORG_ENDPOINTS" | grep "/organisations/:[^/]*" | grep -v "/me" || echo "")

if [[ -n "$HAS_ID_PARAM" ]]; then
  echo "[X] FAIL: Found /organisations/:id endpoint (use /organisations/me for current org)"
  echo "$HAS_ID_PARAM" | sed 's/^/    /'
  FAIL=1
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-mvp-scope-boundaries.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-mvp-scope-boundaries ==="

SCOPE_MANIFEST="docs/scope-manifest.json"
SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SCOPE_MANIFEST" ]] || [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Extract deferred resources from scope-manifest.json
DEFERRED_RESOURCES=$(grep -A 1 '"deferredEntities"' "$SCOPE_MANIFEST" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$DEFERRED_RESOURCES" ]]; then
  echo "[OK] No deferred resources"
  exit 0
fi

echo "Checking MVP scope boundaries for deferred resources:"
echo "$DEFERRED_RESOURCES" | sed 's/^/  - /'

# Check if any endpoint paths contain deferred resource names (loose check)
ENDPOINT_PATHS=$(grep -o '"path": "[^"]*"' "$SERVICE_CONTRACTS" | cut -d'"' -f4)

while IFS= read -r resource; do
  if [[ -z "$resource" ]]; then
    continue
  fi
  
  # Warn if any endpoint path contains the deferred resource name
  MATCHING_ENDPOINTS=$(echo "$ENDPOINT_PATHS" | grep -i "$resource" || echo "")
  
  if [[ -n "$MATCHING_ENDPOINTS" ]]; then
    echo "[WARN] Found endpoints referencing deferred resource '$resource':"
    echo "$MATCHING_ENDPOINTS" | sed 's/^/    /'
    echo "       Verify these are intentionally deferred, not MVP scope leakage"
  fi
done <<< "$DEFERRED_RESOURCES"

# Check deferralDeclarations completeness
DEFERRED_COUNT=$(echo "$DEFERRED_RESOURCES" | wc -l)
DECLARATION_COUNT=$(grep -c '"deferralDeclarations"' "$SCOPE_MANIFEST" || echo "0")

if [[ $DECLARATION_COUNT -eq 0 ]] && [[ $DEFERRED_COUNT -gt 0 ]]; then
  echo "[X] FAIL: Deferred resources exist but no deferralDeclarations section"
  FAIL=1
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-token-scoped-routing.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-token-scoped-routing ==="

SCOPE_MANIFEST="docs/scope-manifest.json"
SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$SCOPE_MANIFEST" ]] || [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Read isolation field from scope-manifest.json
ISOLATION_FIELD=$(grep -o '"isolationField": "[^"]*"' "$SCOPE_MANIFEST" | cut -d'"' -f4)

if [[ -z "$ISOLATION_FIELD" ]]; then
  echo "[SKIP] No tenant isolation configured"
  exit 0
fi

# Extract scope exceptions (paths that don't require tenant scoping)
SCOPE_EXCEPTIONS=$(grep -A 1 '"scopeExceptions"' "$SCOPE_MANIFEST" | grep '"path"' | cut -d'"' -f4)

echo "Checking $ISOLATION_FIELD scoping for org-scoped endpoints"
if [[ -n "$SCOPE_EXCEPTIONS" ]]; then
  echo "Scope exceptions:"
  echo "$SCOPE_EXCEPTIONS" | sed 's/^/  - /'
fi

# Check each authenticated endpoint
AUTH_ENDPOINTS=$(grep -B 2 '"mustUseAuth": true' "$SERVICE_CONTRACTS" | grep '"path"' | cut -d'"' -f4)

if [[ -z "$AUTH_ENDPOINTS" ]]; then
  echo "[OK] No authenticated endpoints"
  exit 0
fi

while IFS= read -r endpoint_path; do
  if [[ -z "$endpoint_path" ]]; then
    continue
  fi
  
  # Skip if path matches any exception pattern (glob-style matching)
  SKIP_ENDPOINT=false
  if [[ -n "$SCOPE_EXCEPTIONS" ]]; then
    while IFS= read -r exception_pattern; do
      # Glob-style matching for patterns like /api/auth/*
      if [[ "$endpoint_path" == $exception_pattern ]]; then
        SKIP_ENDPOINT=true
        echo "[SKIP] $endpoint_path (scope exception: $exception_pattern)"
        break
      fi
    done <<< "$SCOPE_EXCEPTIONS"
  fi
  
  if [[ "$SKIP_ENDPOINT" == "true" ]]; then
    continue
  fi
  
  # Verify routeArgs includes isolation field
  HAS_ISOLATION=$(grep -A 20 '"path": "'$endpoint_path'"' "$SERVICE_CONTRACTS" | grep '"routeArgs"' | grep -c "$ISOLATION_FIELD" || echo "0")
  
  if [[ $HAS_ISOLATION -eq 0 ]]; then
    echo "[X] $endpoint_path: Missing $ISOLATION_FIELD in routeArgs"
    FAIL=1
  else
    echo "[OK] $endpoint_path: $ISOLATION_FIELD scoping present"
  fi
done <<< "$AUTH_ENDPOINTS"

exit $FAIL
#===== END FILE =====#


#===== FILE: scripts/verify-ui-canonical-paths.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-ui-canonical-paths ==="

UI_DEPS="docs/ui-api-deps.json"
FAIL=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[SKIP] ui-api-deps.json not found"
  exit 0
fi

# Verify pages have unique canonical paths
PAGE_PATHS=$(grep -o '"path": "[^"]*"' "$UI_DEPS" | cut -d'"' -f4)

if [[ -z "$PAGE_PATHS" ]]; then
  echo "[OK] No pages defined"
  exit 0
fi

# Check for duplicate paths
DUPLICATE_PATHS=$(echo "$PAGE_PATHS" | sort | uniq -d)

if [[ -n "$DUPLICATE_PATHS" ]]; then
  echo "[X] FAIL: Duplicate page paths found:"
  echo "$DUPLICATE_PATHS" | sed 's/^/    /'
  FAIL=1
else
  PAGE_COUNT=$(echo "$PAGE_PATHS" | wc -l)
  echo "[OK] All $PAGE_COUNT page paths are unique"
fi

# Verify paths follow /resource or /resource/:id pattern
while IFS= read -r path; do
  if [[ -z "$path" ]]; then
    continue
  fi
  
  # Check for valid path patterns
  if [[ ! "$path" =~ ^/[a-z-]+(/:[a-zA-Z]+)?$ ]]; then
    echo "[X] FAIL: Invalid path pattern: $path (use /resource or /resource/:id)"
    FAIL=1
  fi
done <<< "$PAGE_PATHS"

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] All paths follow canonical patterns"
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-ui-api-alignment.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-ui-api-alignment ==="

UI_DEPS="docs/ui-api-deps.json"
SERVICE_CONTRACTS="docs/service-contracts.json"
FAIL=0

if [[ ! -f "$UI_DEPS" ]] || [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Extract page dependencies
PAGE_COUNT=$(grep -c '"path":.*"filePath":' "$UI_DEPS" || echo "0")

if [[ $PAGE_COUNT -eq 0 ]]; then
  echo "[OK] No pages with API dependencies"
  exit 0
fi

echo "Checking UI-API alignment for $PAGE_COUNT pages..."

# For each page, verify referenced endpoints exist in service-contracts
for i in $(seq 0 $((PAGE_COUNT - 1))); do
  PAGE_PATH=$(grep -o '"path": "[^"]*"' "$UI_DEPS" | sed -n "$((i+1))p" | cut -d'"' -f4)
  
  # Extract endpoint references for this page
  ENDPOINT_REFS=$(grep -A 30 '"path": "'$PAGE_PATH'"' "$UI_DEPS" | grep '"endpoint"' | cut -d'"' -f4)
  
  if [[ -z "$ENDPOINT_REFS" ]]; then
    continue
  fi
  
  # Verify each referenced endpoint exists
  while IFS= read -r endpoint; do
    if [[ -z "$endpoint" ]]; then
      continue
    fi
    
    ENDPOINT_EXISTS=$(grep -c '"path": "'$endpoint'"' "$SERVICE_CONTRACTS" || echo "0")
    
    if [[ $ENDPOINT_EXISTS -eq 0 ]]; then
      echo "[X] FAIL: Page $PAGE_PATH references non-existent endpoint: $endpoint"
      FAIL=1
    fi
  done <<< "$ENDPOINT_REFS"
  
  if [[ $FAIL -eq 0 ]]; then
    echo "[OK] $PAGE_PATH API dependencies verified"
  fi
done

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-ui-self-consistency.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-ui-self-consistency ==="

UI_DEPS="docs/ui-api-deps.json"
FAIL=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[SKIP] ui-api-deps.json not found"
  exit 0
fi

# Verify schema version
if ! grep -q '"\$schema": "ui-api-deps-v' "$UI_DEPS"; then
  echo "[X] FAIL: Missing or invalid \$schema field"
  FAIL=1
else
  echo "[OK] Schema version present"
fi

# Verify pages array exists
if ! grep -q '"pages"' "$UI_DEPS"; then
  echo "[X] FAIL: Missing pages array"
  FAIL=1
else
  echo "[OK] pages array present"
fi

# Verify each page has required fields
PAGE_COUNT=$(grep -c '"path":.*"filePath":' "$UI_DEPS" || echo "0")

if [[ $PAGE_COUNT -gt 0 ]]; then
  echo "Validating $PAGE_COUNT page entries..."
  
  for i in $(seq 0 $((PAGE_COUNT - 1))); do
    PAGE_PATH=$(grep -o '"path": "[^"]*"' "$UI_DEPS" | sed -n "$((i+1))p" | cut -d'"' -f4)
    
    # Check for required fields
    HAS_FILE=$(grep -A 2 '"path": "'$PAGE_PATH'"' "$UI_DEPS" | grep -c '"filePath"' || echo "0")
    
    if [[ $HAS_FILE -eq 0 ]]; then
      echo "[X] FAIL: Page $PAGE_PATH missing 'filePath' field"
      FAIL=1
    else
      echo "[OK] $PAGE_PATH has required fields"
    fi
  done
fi

exit $FAIL
#===== END FILE =====#

#===== FILE: scripts/verify-no-deferred-pages.sh =====#
#!/bin/bash
set -euo pipefail
echo "=== verify-no-deferred-pages ==="

UI_DEPS="docs/ui-api-deps.json"
SCOPE_MANIFEST="docs/scope-manifest.json"
FAIL=0

if [[ ! -f "$UI_DEPS" ]] || [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] Required artifacts not found"
  exit 0
fi

# Extract deferred resources
DEFERRED_RESOURCES=$(grep -A 1 '"deferredEntities"' "$SCOPE_MANIFEST" | grep '"name"' | cut -d'"' -f4)

if [[ -z "$DEFERRED_RESOURCES" ]]; then
  echo "[OK] No deferred resources"
  exit 0
fi

# Extract all page paths
PAGE_PATHS=$(grep -o '"path": "[^"]*"' "$UI_DEPS" | cut -d'"' -f4)

echo "Checking for pages referencing deferred resources..."

# Check if any page path contains deferred resource names
while IFS= read -r resource; do
  if [[ -z "$resource" ]]; then
    continue
  fi
  
  MATCHING_PAGES=$(echo "$PAGE_PATHS" | grep -i "$resource" || echo "")
  
  if [[ -n "$MATCHING_PAGES" ]]; then
    echo "[X] FAIL: Found pages referencing deferred resource '$resource':"
    echo "$MATCHING_PAGES" | sed 's/^/    /'
    FAIL=1
  fi
done <<< "$DEFERRED_RESOURCES"

if [[ $FAIL -eq 0 ]]; then
  echo "[OK] No pages reference deferred resources"
fi

exit $FAIL
#===== END FILE =====#

