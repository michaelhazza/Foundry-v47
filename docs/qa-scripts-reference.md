# QA Scripts Reference

Generated by Agent 7 v96 | **Contains ALL QA scripts - use qa-splitter.sh to extract**

## Overview

This file contains 12 QA scripts covering infrastructure, business surface, data integrity, security, response quality, and web integration testing. All scripts read endpoint data from `service-contracts.json` and `scope-manifest.json`. BASE_URL is mandatory with no defaults.

## Scripts Included

| Script | Purpose | Mutation Safety |
|--------|---------|-----------------|
| qa-acquire-tokens.sh | Acquire admin and member tokens for testing | Read-only |
| qa-health-check.sh | Verify health endpoint and basic connectivity | Read-only |
| qa-crud-smoke.sh | Test CRUD operations on all required endpoints | **Requires QA_ALLOW_MUTATION=true** |
| qa-rbac-enforcement.sh | Verify role-based access control | Read-only |
| qa-file-upload-mime.sh | Test file upload MIME type validation | **Requires QA_ALLOW_MUTATION=true** |
| qa-tenancy-isolation.sh | Verify tenant isolation boundaries | **Requires QA_ALLOW_MUTATION=true** |
| qa-unauthenticated-access.sh | Test unauthorized access protection | Read-only |
| qa-input-validation.sh | Test malformed payload handling | **Requires QA_ALLOW_MUTATION=true** |
| qa-response-format.sh | Verify JSON response consistency | Read-only |
| qa-cors-preflight.sh | Test CORS headers and preflight | Read-only |
| run-all-qa-tests.sh | Execute all QA scripts in order | Mixed |

## Execution Order

1. **Infrastructure**: health-check, acquire-tokens
2. **Business Surface**: crud-smoke, rbac-enforcement 
3. **Data Integrity**: tenancy-isolation, file-upload-mime
4. **Security**: unauthenticated-access, input-validation
5. **Response Quality**: response-format
6. **Web Integration**: cors-preflight

---

#===== FILE: scripts/qa-acquire-tokens.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Token Acquisition
# ============================================================================
# Purpose: Acquire admin and member authentication tokens for QA testing
# Reads: service-contracts.json (login endpoint with purpose resolution)
# Exports: ADMIN_TOKEN, MEMBER_TOKEN, USER_TOKEN for other QA scripts
# Safety: Read-only operation (no mutations)

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# QA credentials with defaults
QA_ADMIN_EMAIL="${QA_ADMIN_EMAIL:-admin@example.com}"
QA_ADMIN_PASSWORD="${QA_ADMIN_PASSWORD:-password123}"
QA_MEMBER_EMAIL="${QA_MEMBER_EMAIL:-member@example.com}"
QA_MEMBER_PASSWORD="${QA_MEMBER_PASSWORD:-password123}"

echo "=== QA Token Acquisition ==="
echo "Target: $BASE_URL"
echo ""

# Find login endpoint by purpose (application-agnostic)
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

LOGIN_ENDPOINT=$(jq -r '.endpoints[] | select(.serviceContract.method == "login" and .method == "POST") | .path' service-contracts.json | head -1)

if [[ -z "$LOGIN_ENDPOINT" || "$LOGIN_ENDPOINT" == "null" ]]; then
  echo "[ERROR] No login endpoint found with method='login'"
  exit 1
fi

echo "Login endpoint: $LOGIN_ENDPOINT"

# Extract token path from endpoint configuration
TOKEN_PATH=$(jq -r '.endpoints[] | select(.serviceContract.method == "login" and .method == "POST") | (.responseTokenPath // .serviceContract.responseTokenPath // ".data.accessToken")' service-contracts.json | head -1)

# Sanitise token path for jq usage
TOKEN_PATH=$(echo "$TOKEN_PATH" | sed 's/[^a-zA-Z0-9._-]//g')

echo "Token extraction path: $TOKEN_PATH"
echo ""

# Acquire admin token
echo "Acquiring admin token..."
ADMIN_LOGIN_RESPONSE=$(curl -s -X POST "$BASE_URL$LOGIN_ENDPOINT" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"$QA_ADMIN_EMAIL\",\"password\":\"$QA_ADMIN_PASSWORD\"}")

if echo "$ADMIN_LOGIN_RESPONSE" | jq -e . >/dev/null 2>&1; then
  ADMIN_TOKEN=$(echo "$ADMIN_LOGIN_RESPONSE" | jq -r ".$TOKEN_PATH // empty")
  if [[ -n "$ADMIN_TOKEN" && "$ADMIN_TOKEN" != "null" ]]; then
    echo "[OK] Admin token acquired"
    export ADMIN_TOKEN
  else
    echo "[ERROR] Failed to extract admin token from response"
    echo "Response: $ADMIN_LOGIN_RESPONSE"
    exit 1
  fi
else
  echo "[ERROR] Invalid JSON response for admin login"
  echo "Response: $ADMIN_LOGIN_RESPONSE"
  exit 1
fi

# Acquire member token
echo "Acquiring member token..."
MEMBER_LOGIN_RESPONSE=$(curl -s -X POST "$BASE_URL$LOGIN_ENDPOINT" \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"$QA_MEMBER_EMAIL\",\"password\":\"$QA_MEMBER_PASSWORD\"}")

if echo "$MEMBER_LOGIN_RESPONSE" | jq -e . >/dev/null 2>&1; then
  MEMBER_TOKEN=$(echo "$MEMBER_LOGIN_RESPONSE" | jq -r ".$TOKEN_PATH // empty")
  if [[ -n "$MEMBER_TOKEN" && "$MEMBER_TOKEN" != "null" ]]; then
    echo "[OK] Member token acquired"
    export MEMBER_TOKEN
    # Also export as USER_TOKEN for scripts that need user-level access
    export USER_TOKEN="$MEMBER_TOKEN"
  else
    echo "[ERROR] Failed to extract member token from response"
    echo "Response: $MEMBER_LOGIN_RESPONSE"
    exit 1
  fi
else
  echo "[ERROR] Invalid JSON response for member login"
  echo "Response: $MEMBER_LOGIN_RESPONSE"
  exit 1
fi

echo ""
echo "[OK] Token acquisition complete"
echo "Exported: ADMIN_TOKEN, MEMBER_TOKEN, USER_TOKEN"

#===== FILE: scripts/qa-health-check.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Health Check
# ============================================================================
# Purpose: Verify health endpoint returns 200 and valid JSON
# Reads: service-contracts.json (health endpoint by purpose)
# Safety: Read-only operation

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

echo "=== QA Health Check ==="
echo "Target: $BASE_URL"
echo ""

# Find health endpoint by purpose (application-agnostic)
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

HEALTH_ENDPOINT=$(jq -r '.endpoints[] | select(.serviceContract.notes // "" | test(".*health.*"; "i")) | .path' service-contracts.json | head -1)

if [[ -z "$HEALTH_ENDPOINT" || "$HEALTH_ENDPOINT" == "null" ]]; then
  echo "[ERROR] No health endpoint found"
  exit 1
fi

echo "Health endpoint: $HEALTH_ENDPOINT"

# Test health endpoint
RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$BASE_URL$HEALTH_ENDPOINT")
HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')

echo "HTTP Status: $HTTP_CODE"

# Verify HTTP 200
if [[ "$HTTP_CODE" != "200" ]]; then
  echo "[ERROR] Health check failed - expected 200, got $HTTP_CODE"
  exit 1
fi

# Verify valid JSON response
if ! echo "$BODY" | jq -e . >/dev/null 2>&1; then
  echo "[ERROR] Health endpoint returned invalid JSON"
  echo "Response: $BODY"
  exit 1
fi

echo "[OK] Health check passed - HTTP 200 with valid JSON"
echo ""

#===== FILE: scripts/qa-crud-smoke.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA CRUD Smoke Test
# ============================================================================
# Purpose: Test create/list/getById/update/delete operations on all required endpoints
# Reads: service-contracts.json (endpoints with crudOperation and testPayload)
# Safety: **REQUIRES QA_ALLOW_MUTATION=true** (performs create/update/delete)

if [[ "${QA_ALLOW_MUTATION:-false}" != "true" ]]; then
  echo "[ERROR] CRUD smoke tests require mutations. Set QA_ALLOW_MUTATION=true"
  exit 1
fi

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA CRUD Smoke Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Read required endpoints with CRUD operations
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Test each CRUD endpoint
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  CRUD_OP=$(echo "$endpoint" | jq -r '.crudOperation // empty')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  RBAC=$(echo "$endpoint" | jq -r '.serviceContract.rbac // empty')
  TEST_PAYLOAD=$(echo "$endpoint" | jq -r '.testPayload // empty')
  RESPONSE_ID_PATH=$(echo "$endpoint" | jq -r '.responseIdPath // empty')
  
  # Skip if no CRUD operation declared
  if [[ -z "$CRUD_OP" || "$CRUD_OP" == "null" ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  echo "Testing: $METHOD $PATH (crud: $CRUD_OP)"

  # Select appropriate token based on RBAC requirements
  if [[ "$RBAC" == "admin" ]]; then
    TOKEN="$ADMIN_TOKEN"
  else
    TOKEN="$USER_TOKEN"
  fi

  # Authentication header
  if [[ "$AUTH" == "public" ]]; then
    AUTH_HEADER=""
  else
    AUTH_HEADER="Authorization: Bearer $TOKEN"
  fi

  # Test the endpoint
  case "$CRUD_OP" in
    "create"|"update")
      if [[ -n "$TEST_PAYLOAD" && "$TEST_PAYLOAD" != "null" ]]; then
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
          -H "Content-Type: application/json" \
          ${AUTH_HEADER:+-H "$AUTH_HEADER"} \
          -d "$TEST_PAYLOAD")
        
        if [[ "$HTTP_CODE" =~ ^(200|201|204)$ ]]; then
          echo "[OK] $METHOD $PATH returned $HTTP_CODE"
        else
          echo "[ERROR] $METHOD $PATH returned $HTTP_CODE (expected 200/201/204)"
          FAILURES=$((FAILURES + 1))
        fi
      else
        echo "[SKIP] $METHOD $PATH (no test payload)"
      fi
      ;;
    
    "read"|"list")
      HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
        ${AUTH_HEADER:+-H "$AUTH_HEADER"})
      
      if [[ "$HTTP_CODE" == "200" ]]; then
        echo "[OK] $METHOD $PATH returned $HTTP_CODE"
      else
        echo "[ERROR] $METHOD $PATH returned $HTTP_CODE (expected 200)"
        FAILURES=$((FAILURES + 1))
      fi
      ;;
    
    "delete")
      # For delete operations, we need an ID - skip if we can't get one
      echo "[SKIP] $METHOD $PATH (delete tests require existing resource ID)"
      ;;
  esac

done <<< "$(jq -c '.endpoints[] | select(.status == "required")' service-contracts.json)"

echo ""
echo "=== CRUD Smoke Test Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] CRUD smoke test failed with $FAILURES endpoint failures"
  exit 1
fi

echo "[OK] All CRUD operations successful"

#===== FILE: scripts/qa-rbac-enforcement.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA RBAC Enforcement Test
# ============================================================================
# Purpose: Verify admin-only endpoints reject member tokens with 403
# Reads: service-contracts.json (endpoints with rbac: admin)
# Safety: Read-only operation (sends empty JSON payloads)

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA RBAC Enforcement Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Read admin-only endpoints
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Test each admin-only endpoint with member token
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  RBAC=$(echo "$endpoint" | jq -r '.serviceContract.rbac // empty')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  
  # Skip if not admin-only
  if [[ "$RBAC" != "admin" ]]; then
    continue
  fi

  # Skip if public endpoint
  if [[ "$AUTH" == "public" ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  echo "Testing RBAC: $METHOD $PATH"

  # Test with member token (should get 403)
  if [[ "$METHOD" =~ ^(POST|PUT|PATCH)$ ]]; then
    # Send empty JSON for write methods
    HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $USER_TOKEN" \
      -d '{}')
  else
    HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
      -H "Authorization: Bearer $USER_TOKEN")
  fi

  if [[ "$HTTP_CODE" == "403" ]]; then
    echo "[OK] $METHOD $PATH correctly rejected member access (403)"
  else
    echo "[ERROR] $METHOD $PATH returned $HTTP_CODE with member token (expected 403)"
    FAILURES=$((FAILURES + 1))
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required" and .serviceContract.rbac == "admin")' service-contracts.json)"

echo ""
echo "=== RBAC Enforcement Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] RBAC enforcement failed - $FAILURES endpoints allow unauthorized access"
  exit 1
fi

echo "[OK] All admin-only endpoints properly protected"

#===== FILE: scripts/qa-file-upload-mime.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA File Upload MIME Type Test
# ============================================================================
# Purpose: Test file upload endpoints validate MIME types and size limits
# Reads: service-contracts.json (file upload endpoints with allowedMimeTypes)
# Safety: **REQUIRES QA_ALLOW_MUTATION=true** (uploads test files)

if [[ "${QA_ALLOW_MUTATION:-false}" != "true" ]]; then
  echo "[ERROR] File upload tests require mutations. Set QA_ALLOW_MUTATION=true"
  exit 1
fi

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA File Upload MIME Type Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Read file upload endpoints
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Create test files
mkdir -p /tmp/qa-uploads
echo "test,data" > /tmp/qa-uploads/test.csv
echo '{"test": "data"}' > /tmp/qa-uploads/test.json
echo "invalid content" > /tmp/qa-uploads/test.txt

# Test each file upload endpoint
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  RBAC=$(echo "$endpoint" | jq -r '.serviceContract.rbac // empty')
  FILE_UPLOAD=$(echo "$endpoint" | jq -r '.serviceContract.fileUpload // false')
  
  # Skip if not file upload endpoint
  if [[ "$FILE_UPLOAD" != "true" ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  echo "Testing file upload: $METHOD $PATH"

  # Get allowed MIME types (endpoint-level first, then serviceContract fallback)
  ALLOWED_MIMES=$(echo "$endpoint" | jq -r '(.allowedMimeTypes // .serviceContract.allowedMimeTypes // empty) | if type == "array" then .[0] else . end')
  
  if [[ -z "$ALLOWED_MIMES" || "$ALLOWED_MIMES" == "null" ]]; then
    # Fallback to global file upload config
    ALLOWED_MIMES=$(jq -r '.fileUploadConfig.allowedMimeTypes[0] // "text/csv"' service-contracts.json)
  fi

  # Select appropriate token
  if [[ "$RBAC" == "admin" ]]; then
    TOKEN="$ADMIN_TOKEN"
  else
    TOKEN="$USER_TOKEN"
  fi

  # Authentication header
  if [[ "$AUTH" == "public" ]]; then
    AUTH_HEADER=""
  else
    AUTH_HEADER="Authorization: Bearer $TOKEN"
  fi

  # Test with allowed MIME type
  if [[ "$ALLOWED_MIMES" == "text/csv" ]]; then
    TEST_FILE="/tmp/qa-uploads/test.csv"
    CONTENT_TYPE="text/csv"
  elif [[ "$ALLOWED_MIMES" == "application/json" ]]; then
    TEST_FILE="/tmp/qa-uploads/test.json"
    CONTENT_TYPE="application/json"
  else
    TEST_FILE="/tmp/qa-uploads/test.csv"
    CONTENT_TYPE="text/csv"
  fi

  # Test allowed file type
  HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
    ${AUTH_HEADER:+-H "$AUTH_HEADER"} \
    -F "file=@$TEST_FILE;type=$CONTENT_TYPE")

  if [[ "$HTTP_CODE" =~ ^(200|201|204)$ ]]; then
    echo "[OK] $METHOD $PATH accepted allowed MIME type ($CONTENT_TYPE)"
  else
    echo "[WARN] $METHOD $PATH returned $HTTP_CODE for allowed MIME type ($CONTENT_TYPE)"
  fi

  # Test disallowed file type (text/plain)
  HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
    ${AUTH_HEADER:+-H "$AUTH_HEADER"} \
    -F "file=@/tmp/qa-uploads/test.txt;type=text/plain")

  if [[ "$HTTP_CODE" == "400" ]]; then
    echo "[OK] $METHOD $PATH rejected disallowed MIME type (text/plain)"
  else
    echo "[ERROR] $METHOD $PATH returned $HTTP_CODE for disallowed MIME type (expected 400)"
    FAILURES=$((FAILURES + 1))
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required" and .serviceContract.fileUpload == true)' service-contracts.json)"

# Cleanup
rm -rf /tmp/qa-uploads

echo ""
echo "=== File Upload MIME Test Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] File upload MIME validation failed"
  exit 1
fi

echo "[OK] File upload MIME type validation working correctly"

#===== FILE: scripts/qa-tenancy-isolation.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Tenancy Isolation Test
# ============================================================================
# Purpose: Verify cross-tenant access returns 403/404 when multiTenancy enabled
# Reads: scope-manifest.json (multiTenancy config) and service-contracts.json
# Safety: **REQUIRES QA_ALLOW_MUTATION=true** (creates test resources)

if [[ "${QA_ALLOW_MUTATION:-false}" != "true" ]]; then
  echo "[ERROR] Tenancy isolation tests require mutations. Set QA_ALLOW_MUTATION=true"
  exit 1
fi

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Check if multi-tenancy is enabled
if [[ ! -f "scope-manifest.json" ]]; then
  echo "[INFO] scope-manifest.json not found - skipping tenancy isolation tests"
  exit 0
fi

MULTI_TENANCY=$(jq -r '.platformConstraints.multiTenancy.model // empty' scope-manifest.json)
if [[ -z "$MULTI_TENANCY" || "$MULTI_TENANCY" == "null" ]]; then
  echo "[INFO] Multi-tenancy not configured - skipping tenancy isolation tests"
  exit 0
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA Tenancy Isolation Test ==="
echo "Target: $BASE_URL"
echo "Multi-tenancy model: $MULTI_TENANCY"
echo ""

FAILURES=0

# Create test resource with admin token to get ID
echo "Creating test resource for isolation testing..."

# Find a create endpoint that returns an ID
CREATE_ENDPOINT=$(jq -r '.endpoints[] | select(.status == "required" and .method == "POST" and .crudOperation == "create" and (.responseIdPath // empty) != "") | .path' service-contracts.json | head -1)

if [[ -z "$CREATE_ENDPOINT" || "$CREATE_ENDPOINT" == "null" ]]; then
  echo "[SKIP] No suitable create endpoint found for tenancy testing"
  exit 0
fi

echo "Using create endpoint: $CREATE_ENDPOINT"

# Get test payload and response ID path
TEST_PAYLOAD=$(jq -r '.endpoints[] | select(.path == "'"$CREATE_ENDPOINT"'" and .method == "POST") | .testPayload // empty' service-contracts.json)
ID_PATH=$(jq -r '.endpoints[] | select(.path == "'"$CREATE_ENDPOINT"'" and .method == "POST") | .responseIdPath // empty' service-contracts.json)

if [[ -z "$TEST_PAYLOAD" || "$TEST_PAYLOAD" == "null" ]]; then
  echo "[SKIP] No test payload available for $CREATE_ENDPOINT"
  exit 0
fi

# Sanitise ID path for jq usage
ID_PATH=$(echo "$ID_PATH" | sed 's/[^a-zA-Z0-9._-]//g')

# Create resource with admin token
CREATE_RESPONSE=$(curl -s -X POST "$BASE_URL$CREATE_ENDPOINT" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d "$TEST_PAYLOAD")

if echo "$CREATE_RESPONSE" | jq -e . >/dev/null 2>&1; then
  RESOURCE_ID=$(echo "$CREATE_RESPONSE" | jq -r ".$ID_PATH // empty")
  if [[ -n "$RESOURCE_ID" && "$RESOURCE_ID" != "null" ]]; then
    echo "[OK] Test resource created with ID: $RESOURCE_ID"
  else
    echo "[SKIP] Could not extract resource ID from create response"
    exit 0
  fi
else
  echo "[SKIP] Create request failed - cannot test tenancy isolation"
  exit 0
fi

# Test cross-tenant access on parameterized endpoints
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  
  # Skip public endpoints
  if [[ "$AUTH" == "public" ]]; then
    continue
  fi

  # Skip if not parameterized (no :id pattern)
  if [[ ! "$PATH" =~ :[a-zA-Z]+ ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    continue
  fi

  # Replace parameter with test resource ID
  TEST_PATH=$(echo "$PATH" | sed 's/:id/'"$RESOURCE_ID"'/g' | sed 's/:projectId/'"$RESOURCE_ID"'/g')
  
  echo "Testing tenancy isolation: $METHOD $TEST_PATH"

  # Test with member token (different tenant context)
  HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$TEST_PATH" \
    -H "Authorization: Bearer $USER_TOKEN")

  if [[ "$HTTP_CODE" =~ ^(403|404)$ ]]; then
    echo "[OK] $METHOD $TEST_PATH properly isolated (returned $HTTP_CODE)"
  else
    echo "[WARN] $METHOD $TEST_PATH returned $HTTP_CODE (expected 403/404 for cross-tenant access)"
    # Don't fail here as some endpoints may legitimately return other codes
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required")' service-contracts.json)"

echo ""
echo "=== Tenancy Isolation Summary ==="
echo "[OK] Tenancy isolation tests completed"

#===== FILE: scripts/qa-unauthenticated-access.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Unauthenticated Access Test
# ============================================================================
# Purpose: Verify protected endpoints reject requests without tokens (401/403)
# Reads: service-contracts.json (endpoints with authentication: required)
# Safety: Read-only operation (no authentication tokens sent)

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

echo "=== QA Unauthenticated Access Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Read protected endpoints
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Test each protected endpoint without authentication
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  
  # Skip public endpoints
  if [[ "$AUTH" == "public" ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  echo "Testing unauthenticated access: $METHOD $PATH"

  # Send request without authentication
  HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH")

  if [[ "$HTTP_CODE" =~ ^(401|403)$ ]]; then
    echo "[OK] $METHOD $PATH correctly rejected unauthenticated request ($HTTP_CODE)"
  else
    echo "[ERROR] $METHOD $PATH returned $HTTP_CODE without auth (expected 401/403)"
    FAILURES=$((FAILURES + 1))
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required")' service-contracts.json)"

echo ""
echo "=== Unauthenticated Access Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] Authentication enforcement failed - $FAILURES endpoints allow unauthenticated access"
  exit 1
fi

echo "[OK] All protected endpoints require authentication"

#===== FILE: scripts/qa-input-validation.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Input Validation Test
# ============================================================================
# Purpose: Test endpoints reject malformed payloads with 400 (not 500)
# Reads: service-contracts.json (endpoints that accept request bodies)
# Safety: **REQUIRES QA_ALLOW_MUTATION=true** (sends malformed data)

if [[ "${QA_ALLOW_MUTATION:-false}" != "true" ]]; then
  echo "[ERROR] Input validation tests require mutations. Set QA_ALLOW_MUTATION=true"
  exit 1
fi

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA Input Validation Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Malformed payloads to test
MALFORMED_PAYLOADS=(
  '{"invalid": json}'  # Invalid JSON syntax
  '{"missing_required_field": true}'  # Missing required fields
  '{}'  # Empty object
  'null'  # Null payload
)

# Read endpoints that accept request bodies
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Test each endpoint that accepts body
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  RBAC=$(echo "$endpoint" | jq -r '.serviceContract.rbac // empty')
  ACCEPTS_BODY=$(echo "$endpoint" | jq -r '.serviceContract.acceptsBody // false')
  
  # Skip if doesn't accept body
  if [[ "$ACCEPTS_BODY" != "true" ]]; then
    continue
  fi

  # Skip GET requests (they shouldn't have bodies)
  if [[ "$METHOD" == "GET" ]]; then
    continue
  fi

  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  echo "Testing input validation: $METHOD $PATH"

  # Select appropriate token
  if [[ "$RBAC" == "admin" ]]; then
    TOKEN="$ADMIN_TOKEN"
  else
    TOKEN="$USER_TOKEN"
  fi

  # Authentication header
  if [[ "$AUTH" == "public" ]]; then
    AUTH_HEADER=""
  else
    AUTH_HEADER="Authorization: Bearer $TOKEN"
  fi

  # Test with malformed JSON
  HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X "$METHOD" "$BASE_URL$PATH" \
    -H "Content-Type: application/json" \
    ${AUTH_HEADER:+-H "$AUTH_HEADER"} \
    -d '{"invalid": json}')

  if [[ "$HTTP_CODE" == "400" ]]; then
    echo "[OK] $METHOD $PATH rejected malformed JSON (400)"
  elif [[ "$HTTP_CODE" == "500" ]]; then
    echo "[ERROR] $METHOD $PATH returned 500 for malformed JSON (should be 400)"
    FAILURES=$((FAILURES + 1))
  else
    echo "[WARN] $METHOD $PATH returned $HTTP_CODE for malformed JSON (expected 400)"
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required" and .serviceContract.acceptsBody == true)' service-contracts.json)"

echo ""
echo "=== Input Validation Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] Input validation failed - $FAILURES endpoints return 500 instead of 400"
  exit 1
fi

echo "[OK] All endpoints handle malformed input correctly"

#===== FILE: scripts/qa-response-format.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Response Format Consistency Test
# ============================================================================
# Purpose: Verify all required endpoints return valid JSON responses
# Reads: service-contracts.json (all required endpoints)
# Safety: Read-only operation

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

# Source tokens from acquire-tokens script
if [[ -z "${ADMIN_TOKEN:-}" || -z "${USER_TOKEN:-}" ]]; then
  echo "Sourcing tokens..."
  source scripts/qa-acquire-tokens.sh
fi

echo "=== QA Response Format Consistency Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0

# Read all required endpoints
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Test each required endpoint for JSON response
while IFS= read -r endpoint; do
  PATH=$(echo "$endpoint" | jq -r '.path')
  METHOD=$(echo "$endpoint" | jq -r '.method')
  AUTH=$(echo "$endpoint" | jq -r '.authentication // "required"')
  RBAC=$(echo "$endpoint" | jq -r '.serviceContract.rbac // empty')
  
  # Skip deferred endpoints
  STATUS=$(echo "$endpoint" | jq -r '.status // "required"')
  if [[ "$STATUS" != "required" ]]; then
    echo "[SKIP] $METHOD $PATH (status: $STATUS)"
    continue
  fi

  # Skip non-GET endpoints to avoid mutations
  if [[ "$METHOD" != "GET" ]]; then
    continue
  fi

  echo "Testing response format: $METHOD $PATH"

  # Select appropriate token
  if [[ "$RBAC" == "admin" ]]; then
    TOKEN="$ADMIN_TOKEN"
  else
    TOKEN="$USER_TOKEN"
  fi

  # Authentication header
  if [[ "$AUTH" == "public" ]]; then
    AUTH_HEADER=""
  else
    AUTH_HEADER="Authorization: Bearer $TOKEN"
  fi

  # Test response format
  RESPONSE=$(curl -s -X "$METHOD" "$BASE_URL$PATH" \
    ${AUTH_HEADER:+-H "$AUTH_HEADER"})

  # Verify valid JSON
  if echo "$RESPONSE" | jq -e . >/dev/null 2>&1; then
    echo "[OK] $METHOD $PATH returned valid JSON"
  else
    echo "[ERROR] $METHOD $PATH returned invalid JSON"
    echo "Response: $RESPONSE"
    FAILURES=$((FAILURES + 1))
  fi

done <<< "$(jq -c '.endpoints[] | select(.status == "required" and .method == "GET")' service-contracts.json)"

echo ""
echo "=== Response Format Summary: $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] Response format validation failed"
  exit 1
fi

echo "[OK] All endpoints return valid JSON responses"

#===== FILE: scripts/qa-cors-preflight.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA CORS Preflight Test
# ============================================================================
# Purpose: Verify CORS headers are present for web browser compatibility
# Reads: service-contracts.json (all required endpoints)
# Safety: Read-only operation (sends OPTIONS requests)

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

echo "=== QA CORS Preflight Test ==="
echo "Target: $BASE_URL"
echo ""

FAILURES=0
TESTED=0

# Read all required endpoints
if [[ ! -f "service-contracts.json" ]]; then
  echo "[ERROR] service-contracts.json not found"
  exit 1
fi

# Extract unique paths for CORS testing
TEST_PATHS=$(jq -r '.endpoints[] | select(.status == "required") | .path' service-contracts.json | sort -u)

# Test CORS preflight for each unique path
while IFS= read -r route_path; do
  # Skip parameterized paths for CORS testing
  if [[ "$route_path" =~ :[a-zA-Z]+ ]]; then
    continue
  fi

  TESTED=$((TESTED + 1))
  echo "Testing CORS preflight: $route_path"

  # Send OPTIONS request
  RESPONSE_HEADERS=$(curl -s -I -X OPTIONS "$BASE_URL$route_path" \
    -H "Origin: https://example.com" \
    -H "Access-Control-Request-Method: GET" \
    -H "Access-Control-Request-Headers: Content-Type,Authorization" 2>/dev/null || echo "")

  if [[ -z "$RESPONSE_HEADERS" ]]; then
    echo "[ERROR] OPTIONS $route_path - no response received"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  # Extract HTTP status code
  HTTP_CODE=$(echo "$RESPONSE_HEADERS" | head -1 | grep -oE '[0-9]{3}')

  # Verify 2xx status
  if ! echo "$HTTP_CODE" | grep -qE '^2[0-9]{2}$'; then
    echo "[ERROR] OPTIONS $route_path returned $HTTP_CODE (expected 2xx)"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  # Verify Allow-Methods includes GET
  ALLOW_METHODS=$(echo "$RESPONSE_HEADERS" | grep -i "access-control-allow-methods" | head -1)
  if ! echo "$ALLOW_METHODS" | grep -qi "GET"; then
    echo "[WARN] OPTIONS $route_path Access-Control-Allow-Methods does not include GET"
  fi

  # Verify origin is not wildcard if we have a specific expected origin
  ACTUAL_ORIGIN=$(echo "$RESPONSE_HEADERS" | grep -i "access-control-allow-origin" | head -1 | awk '{print $2}' | tr -d '\r')
  if [[ "$ACTUAL_ORIGIN" == "*" ]]; then
    echo "[WARN] OPTIONS $route_path uses wildcard origin (*) -- acceptable in dev, not production"
  else
    echo "[OK] OPTIONS $route_path -- CORS headers present, 2xx status (origin: $ACTUAL_ORIGIN)"
  fi

done <<< "$TEST_PATHS"

echo ""
echo "=== CORS Preflight Summary: $TESTED paths tested, $FAILURES failures ==="

if [[ $FAILURES -gt 0 ]]; then
  echo "[ERROR] CORS QA FAILED: $FAILURES endpoints missing CORS headers"
  exit 1
fi

echo "[OK] CORS preflight headers present on all tested endpoints"

#===== FILE: scripts/run-all-qa-tests.sh =====#
#!/bin/bash
set -e

# ============================================================================
# QA Test Runner
# ============================================================================
# Purpose: Execute all QA scripts in proper order with failure tracking
# Safety: Mixed (some read-only, some require QA_ALLOW_MUTATION=true)

# Split-first guard: ensure scripts are extracted
if [[ ! -f "scripts/qa-acquire-tokens.sh" ]]; then
  echo "QA scripts not found. Running splitter first..."
  if [[ -f "docs/qa-splitter.sh" ]]; then
    bash docs/qa-splitter.sh
  else
    echo "[ERROR] qa-splitter.sh not found. Run Agent 7 first."
    exit 1
  fi
fi

if [[ -z "${BASE_URL:-}" ]]; then
  echo "[ERROR] BASE_URL environment variable must be set"
  echo "Example: export BASE_URL=https://api.example.com"
  exit 1
fi

echo "========================================="
echo "QA Test Suite"
echo "========================================="
echo "Target: $BASE_URL"
echo "Mutation allowed: ${QA_ALLOW_MUTATION:-false}"
echo ""

TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Test execution order
TESTS=(
  "qa-health-check.sh:Infrastructure:Health check and connectivity"
  "qa-acquire-tokens.sh:Infrastructure:Authentication token acquisition"
  "qa-crud-smoke.sh:Business Surface:CRUD operations smoke test"
  "qa-rbac-enforcement.sh:Business Surface:Role-based access control"
  "qa-file-upload-mime.sh:Data Integrity:File upload MIME validation"
  "qa-tenancy-isolation.sh:Data Integrity:Multi-tenant isolation"
  "qa-unauthenticated-access.sh:Security:Unauthorized access protection"
  "qa-input-validation.sh:Security:Input validation and error handling"
  "qa-response-format.sh:Response Quality:JSON response consistency"
  "qa-cors-preflight.sh:Web Integration:CORS preflight headers"
)

for test_info in "${TESTS[@]}"; do
  IFS=':' read -r script category description <<< "$test_info"
  
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
  
  echo "========================================="
  echo "[$category] $description"
  echo "========================================="
  
  if bash "scripts/$script"; then
    echo "[✓] $script PASSED"
    PASSED_TESTS=$((PASSED_TESTS + 1))
  else
    echo "[✗] $script FAILED"
    FAILED_TESTS=$((FAILED_TESTS + 1))
  fi
  
  echo ""
done

echo "========================================="
echo "QA Test Suite Summary"
echo "========================================="
echo "Total tests: $TOTAL_TESTS"
echo "Passed: $PASSED_TESTS"
echo "Failed: $FAILED_TESTS"
echo ""

if [[ $FAILED_TESTS -gt 0 ]]; then
  echo "[FAIL] QA test suite failed with $FAILED_TESTS failures"
  exit 1
fi

echo "[PASS] All QA tests passed successfully"
echo "Application is ready for deployment"
